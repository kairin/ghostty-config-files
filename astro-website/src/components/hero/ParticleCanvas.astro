---
// ParticleCanvas.astro - Dynamic canvas-based particle system with shooting stars
// GPU-accelerated animated background for dramatic visual effect

interface Props {
  class?: string;
}

const { class: className = '' } = Astro.props;
---

<canvas
  id="particle-canvas"
  class:list={['absolute inset-0 w-full h-full pointer-events-none', className]}
  aria-hidden="true"
></canvas>

<script>
  // Configuration
  const CONFIG = {
    particleCount: window.innerWidth < 768 ? 80 : 200,
    parallaxLayers: window.innerWidth < 768 ? 1 : 3,
    shootingStarInterval: { min: 2000, max: 3000 },
    colors: ['#ffffff', '#38bdf8', '#22d3ee', '#a5f3fc'],
  };

  // Particle class
  class Particle {
    x: number = 0;
    y: number = 0;
    vx: number = 0;
    vy: number = 0;
    size: number = 1;
    opacity: number = 1;
    layer: number = 0;
    color: string = '#ffffff';
    twinkleSpeed: number = 0;
    twinkleOffset: number = 0;

    constructor(private canvas: HTMLCanvasElement) {
      this.reset();
    }

    reset() {
      this.x = Math.random() * this.canvas.width;
      this.y = Math.random() * this.canvas.height;
      this.layer = Math.floor(Math.random() * CONFIG.parallaxLayers);

      // Speed based on layer (parallax effect)
      const layerSpeed = (this.layer + 1) * 0.15;
      this.vx = (Math.random() - 0.5) * layerSpeed;
      this.vy = (Math.random() - 0.5) * layerSpeed;

      // Size based on layer (further = smaller)
      this.size = (CONFIG.parallaxLayers - this.layer) * 1.2 + Math.random() * 1.5;

      // Color
      this.color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];

      // Twinkling
      this.twinkleSpeed = Math.random() * 0.02 + 0.01;
      this.twinkleOffset = Math.random() * Math.PI * 2;
      this.opacity = 0.3 + Math.random() * 0.7;
    }

    update(time: number, mouseX: number, mouseY: number) {
      // Move particle
      this.x += this.vx;
      this.y += this.vy;

      // Wrap around edges
      if (this.x < 0) this.x = this.canvas.width;
      if (this.x > this.canvas.width) this.x = 0;
      if (this.y < 0) this.y = this.canvas.height;
      if (this.y > this.canvas.height) this.y = 0;

      // Mouse interaction (subtle repulsion)
      const dx = this.x - mouseX;
      const dy = this.y - mouseY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 150 && dist > 0) {
        const force = (150 - dist) / 150 * 0.3;
        this.x += (dx / dist) * force;
        this.y += (dy / dist) * force;
      }

      // Twinkling effect
      this.opacity = 0.4 + Math.sin(time * this.twinkleSpeed + this.twinkleOffset) * 0.4 + 0.2;
    }

    draw(ctx: CanvasRenderingContext2D) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.globalAlpha = this.opacity;
      ctx.fill();

      // Glow effect for larger particles
      if (this.size > 2) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.opacity * 0.2;
        ctx.fill();
      }
    }
  }

  // Shooting Star class
  class ShootingStar {
    x: number = 0;
    y: number = 0;
    vx: number = 0;
    vy: number = 0;
    length: number = 0;
    trail: Array<{ x: number; y: number; opacity: number }> = [];
    active: boolean = false;
    opacity: number = 1;

    constructor(private canvas: HTMLCanvasElement) {}

    spawn() {
      // Start from top or right edge
      if (Math.random() > 0.5) {
        this.x = Math.random() * this.canvas.width;
        this.y = -20;
      } else {
        this.x = this.canvas.width + 20;
        this.y = Math.random() * this.canvas.height * 0.5;
      }

      // Angle: moving down-left
      const angle = Math.PI * 0.6 + Math.random() * 0.4;
      const speed = 15 + Math.random() * 10;
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed;

      this.length = 80 + Math.random() * 60;
      this.trail = [];
      this.active = true;
      this.opacity = 1;
    }

    update() {
      if (!this.active) return;

      // Add current position to trail
      this.trail.unshift({ x: this.x, y: this.y, opacity: 1 });

      // Limit trail length
      if (this.trail.length > 25) {
        this.trail.pop();
      }

      // Update trail opacity
      this.trail.forEach((point, i) => {
        point.opacity = 1 - i / this.trail.length;
      });

      // Move
      this.x += this.vx;
      this.y += this.vy;

      // Deactivate when off screen
      if (this.x < -100 || this.y > this.canvas.height + 100) {
        this.active = false;
      }
    }

    draw(ctx: CanvasRenderingContext2D) {
      if (!this.active || this.trail.length < 2) return;

      // Draw trail
      ctx.beginPath();
      ctx.moveTo(this.trail[0].x, this.trail[0].y);

      for (let i = 1; i < this.trail.length; i++) {
        ctx.lineTo(this.trail[i].x, this.trail[i].y);
      }

      // Gradient for trail
      const gradient = ctx.createLinearGradient(
        this.trail[0].x, this.trail[0].y,
        this.trail[this.trail.length - 1].x, this.trail[this.trail.length - 1].y
      );
      gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
      gradient.addColorStop(0.3, 'rgba(56, 189, 248, 0.8)');
      gradient.addColorStop(1, 'rgba(56, 189, 248, 0)');

      ctx.strokeStyle = gradient;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.globalAlpha = this.opacity;
      ctx.stroke();

      // Bright head
      ctx.beginPath();
      ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 1;
      ctx.fill();
    }
  }

  // Main Particle System
  class ParticleSystem {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private particles: Particle[] = [];
    private shootingStars: ShootingStar[] = [];
    private animationId: number = 0;
    private lastTime: number = 0;
    private mouseX: number = 0;
    private mouseY: number = 0;
    private running: boolean = false;
    private shootingStarTimer: number = 0;

    constructor(canvasId: string) {
      const canvas = document.getElementById(canvasId) as HTMLCanvasElement;
      if (!canvas) throw new Error('Canvas not found');

      this.canvas = canvas;
      this.ctx = canvas.getContext('2d')!;

      this.handleResize();
      this.initParticles();
      this.setupEventListeners();
    }

    private handleResize = () => {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();

      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;

      this.ctx.scale(dpr, dpr);
      this.canvas.style.width = `${rect.width}px`;
      this.canvas.style.height = `${rect.height}px`;
    };

    private initParticles() {
      this.particles = [];
      for (let i = 0; i < CONFIG.particleCount; i++) {
        this.particles.push(new Particle(this.canvas));
      }

      // Pre-create shooting star pool
      this.shootingStars = [];
      for (let i = 0; i < 3; i++) {
        this.shootingStars.push(new ShootingStar(this.canvas));
      }
    }

    private setupEventListeners() {
      window.addEventListener('resize', () => {
        this.handleResize();
        this.particles.forEach(p => p.reset());
      });

      document.addEventListener('mousemove', (e) => {
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
      });

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          this.stop();
        } else {
          this.start();
        }
      });
    }

    private spawnShootingStar() {
      const inactive = this.shootingStars.find(s => !s.active);
      if (inactive) {
        inactive.spawn();
      }
    }

    private animate = (currentTime: number) => {
      if (!this.running) return;

      const deltaTime = currentTime - this.lastTime;
      this.lastTime = currentTime;

      // Clear canvas
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Reset global alpha
      this.ctx.globalAlpha = 1;

      // Spawn shooting stars periodically
      this.shootingStarTimer += deltaTime;
      const interval = CONFIG.shootingStarInterval.min +
        Math.random() * (CONFIG.shootingStarInterval.max - CONFIG.shootingStarInterval.min);
      if (this.shootingStarTimer > interval) {
        this.spawnShootingStar();
        this.shootingStarTimer = 0;
      }

      // Update and draw particles by layer (back to front for parallax)
      for (let layer = 0; layer < CONFIG.parallaxLayers; layer++) {
        this.particles
          .filter(p => p.layer === layer)
          .forEach(p => {
            p.update(currentTime, this.mouseX, this.mouseY);
            p.draw(this.ctx);
          });
      }

      // Update and draw shooting stars
      this.shootingStars.forEach(star => {
        star.update();
        star.draw(this.ctx);
      });

      this.animationId = requestAnimationFrame(this.animate);
    };

    start() {
      if (this.running) return;
      this.running = true;
      this.lastTime = performance.now();
      this.animationId = requestAnimationFrame(this.animate);
    }

    stop() {
      this.running = false;
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }

  // Initialize on DOM ready
  document.addEventListener('DOMContentLoaded', () => {
    try {
      const system = new ParticleSystem('particle-canvas');
      system.start();
    } catch (e) {
      console.warn('ParticleCanvas initialization failed:', e);
    }
  });
</script>
