---
/**
 * GifRotator Component
 * Rotates through multiple GIF segments with VHS glitch effects
 * Features: crossfade transitions, scanlines, static noise, tracking wobble
 */

interface Props {
  id: string;
  gifs: string[];
  interval?: number;  // Rotation interval in ms (default: 10000)
  vhsGlitch?: boolean;  // Enable VHS effects (default: true)
  opacity?: number;  // GIF opacity 0-1 (default: 0.15)
  class?: string;
}

const {
  id,
  gifs,
  interval = 10000,
  vhsGlitch = true,
  opacity = 0.15,
  class: className = ''
} = Astro.props;

const base = import.meta.env.BASE_URL;
const gifUrls = gifs.map(g => g.startsWith('/') ? `${base}${g}` : `${base}/${g}`);
---

<div
  class={`gif-rotator ${className}`}
  id={id}
  data-gifs={JSON.stringify(gifUrls)}
  data-interval={interval}
  data-opacity={opacity}
  data-vhs={vhsGlitch}
>
  <!-- Primary GIF layer (visible) -->
  <img
    class="gif-layer gif-primary"
    src={gifUrls[0]}
    alt=""
    aria-hidden="true"
    loading="eager"
  />

  <!-- Secondary GIF layer (for crossfade) -->
  <img
    class="gif-layer gif-secondary"
    src={gifUrls[1] || gifUrls[0]}
    alt=""
    aria-hidden="true"
    loading="lazy"
  />

  {vhsGlitch && (
    <div class="vhs-overlay">
      <!-- Scanlines effect -->
      <div class="vhs-scanlines"></div>
      <!-- Static noise -->
      <div class="vhs-static"></div>
      <!-- Chromatic aberration -->
      <div class="vhs-color-shift"></div>
    </div>
  )}

  <!-- Gradient overlay for text readability -->
  <div class="gif-overlay"></div>
</div>

<script>
  interface GifRotatorElement extends HTMLElement {
    dataset: {
      gifs: string;
      interval: string;
      opacity: string;
      vhs: string;
    };
  }

  class GifRotatorController {
    private container: GifRotatorElement;
    private gifs: string[];
    private interval: number;
    private currentIndex: number = 0;
    private timer: number | null = null;
    private primary: HTMLImageElement | null;
    private secondary: HTMLImageElement | null;
    private preloadedImages: Map<string, HTMLImageElement> = new Map();
    private isPaused: boolean = false;

    constructor(container: GifRotatorElement) {
      this.container = container;
      this.gifs = JSON.parse(container.dataset.gifs || '[]');
      this.interval = parseInt(container.dataset.interval || '10000', 10);
      this.primary = container.querySelector('.gif-primary');
      this.secondary = container.querySelector('.gif-secondary');

      // Set initial opacity
      const opacity = parseFloat(container.dataset.opacity || '0.15');
      if (this.primary) this.primary.style.opacity = String(opacity);
      if (this.secondary) this.secondary.style.opacity = '0';

      this.init();
    }

    private init() {
      if (this.gifs.length <= 1) return;

      // Preload all images
      this.gifs.forEach(src => this.preloadImage(src));

      // Start rotation
      this.startRotation();

      // Pause on tab hidden
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          this.pause();
        } else {
          this.resume();
        }
      });

      // Respect reduced motion
      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        this.pause();
        // Hide VHS effects
        const vhsOverlay = this.container.querySelector('.vhs-overlay');
        if (vhsOverlay) (vhsOverlay as HTMLElement).style.display = 'none';
      }
    }

    private preloadImage(src: string): Promise<HTMLImageElement> {
      if (this.preloadedImages.has(src)) {
        return Promise.resolve(this.preloadedImages.get(src)!);
      }

      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          this.preloadedImages.set(src, img);
          resolve(img);
        };
        img.onerror = () => resolve(img);
        img.src = src;
      });
    }

    private startRotation() {
      if (this.timer) return;
      this.timer = window.setInterval(() => this.rotate(), this.interval);
    }

    private rotate() {
      if (this.isPaused || !this.primary || !this.secondary) return;

      const nextIndex = (this.currentIndex + 1) % this.gifs.length;
      const nextSrc = this.gifs[nextIndex];
      const opacity = parseFloat(this.container.dataset.opacity || '0.15');

      // Trigger VHS glitch effect during transition
      this.triggerGlitch();

      // Set next image on secondary layer
      this.secondary.src = nextSrc;

      // Crossfade animation
      this.secondary.style.opacity = String(opacity);
      this.primary.style.opacity = '0';

      // After transition, swap layers
      setTimeout(() => {
        if (this.primary && this.secondary) {
          this.primary.src = nextSrc;
          this.primary.style.opacity = String(opacity);
          this.secondary.style.opacity = '0';
        }
        this.currentIndex = nextIndex;

        // Preload next image
        const preloadIndex = (nextIndex + 1) % this.gifs.length;
        this.preloadImage(this.gifs[preloadIndex]);
      }, 500);
    }

    private triggerGlitch() {
      const vhsOverlay = this.container.querySelector('.vhs-overlay');
      if (!vhsOverlay) return;

      // Add intense glitch class
      vhsOverlay.classList.add('glitch-active');

      // Remove after short duration
      setTimeout(() => {
        vhsOverlay.classList.remove('glitch-active');
      }, 300);
    }

    pause() {
      this.isPaused = true;
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
    }

    resume() {
      if (!this.isPaused) return;
      this.isPaused = false;
      this.startRotation();
    }
  }

  // Initialize all GifRotator instances
  function initGifRotators() {
    document.querySelectorAll<GifRotatorElement>('.gif-rotator').forEach(container => {
      new GifRotatorController(container);
    });
  }

  // Initialize on page load
  initGifRotators();

  // Re-initialize on Astro page navigation
  document.addEventListener('astro:page-load', initGifRotators);
</script>

<style>
  .gif-rotator {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  .gif-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: opacity 0.5s ease-in-out;
  }

  .gif-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      180deg,
      rgba(255, 255, 255, 0.7) 0%,
      rgba(255, 255, 255, 0.5) 50%,
      rgba(255, 255, 255, 0.7) 100%
    );
    pointer-events: none;
  }

  :global(html.dark) .gif-overlay,
  :global([data-theme="dark"]) .gif-overlay {
    background: linear-gradient(
      180deg,
      rgba(15, 23, 42, 0.7) 0%,
      rgba(15, 23, 42, 0.5) 50%,
      rgba(15, 23, 42, 0.7) 100%
    );
  }

  /* VHS Effects */
  .vhs-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 5;
  }

  /* Scanlines - horizontal lines */
  .vhs-scanlines {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.1) 2px,
      rgba(0, 0, 0, 0.1) 4px
    );
    animation: scanline-flicker 0.1s infinite;
    opacity: 0.5;
  }

  /* Static noise - TV snow effect */
  .vhs-static {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    opacity: 0.03;
    animation: vhs-noise 0.5s steps(10) infinite;
  }

  /* Chromatic aberration - RGB shift */
  .vhs-color-shift {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      90deg,
      rgba(255, 0, 0, 0.03) 0%,
      transparent 50%,
      rgba(0, 0, 255, 0.03) 100%
    );
    animation: color-shift 3s ease-in-out infinite;
  }

  /* Glitch intensification during transitions */
  .vhs-overlay.glitch-active .vhs-scanlines {
    opacity: 0.8;
  }

  .vhs-overlay.glitch-active .vhs-static {
    opacity: 0.1;
  }

  .vhs-overlay.glitch-active .vhs-color-shift {
    animation: vhs-tracking 0.3s ease-out;
  }

  /* VHS Animations */
  @keyframes scanline-flicker {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 0.6; }
  }

  @keyframes vhs-noise {
    0%, 100% { background-position: 0 0; }
    10% { background-position: -5% -10%; }
    30% { background-position: 7% -25%; }
    50% { background-position: -25% 10%; }
    70% { background-position: 0% 15%; }
    90% { background-position: -10% 10%; }
  }

  @keyframes vhs-tracking {
    0% { transform: translateX(0); }
    10% { transform: translateX(-3px) skewX(-1deg); }
    20% { transform: translateX(3px) skewX(1deg); }
    30% { transform: translateX(-2px); }
    40% { transform: translateX(2px); }
    50% { transform: translateX(0); }
    100% { transform: translateX(0); }
  }

  @keyframes color-shift {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-1px); }
    75% { transform: translateX(1px); }
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .vhs-scanlines,
    .vhs-static,
    .vhs-color-shift {
      animation: none;
    }

    .gif-layer {
      transition: none;
    }
  }
</style>
