---
/**
 * Interactive Tutorial Component
 * Constitutional compliance: Zero JavaScript by default, progressive enhancement
 * Features: Step-by-step onboarding, accessibility-first, keyboard navigation
 */

interface Props {
  tutorialId: string;
  title?: string;
  description?: string;
  steps?: Array<{
    id: string;
    title: string;
    content: string;
    target?: string;
    action?: string;
    validation?: string;
  }>;
  autoStart?: boolean;
  class?: string;
}

const {
  tutorialId,
  title = "Getting Started Tutorial",
  description = "Learn how to use the constitutional framework effectively",
  steps = [],
  autoStart = false,
  class: className
} = Astro.props;

// Default tutorial steps for different tutorials
const defaultSteps = {
  getting_started: [
    {
      id: "welcome",
      title: "Welcome to Constitutional Framework",
      content: "This tutorial will guide you through the key features and concepts of our constitutional web development framework.",
      target: ".hero-section",
      action: "highlight",
      validation: undefined
    },
    {
      id: "navigation",
      title: "Navigation Overview",
      content: "Use the main navigation to access documentation, components, guides, and tools. All sections follow constitutional principles.",
      target: "nav[role='navigation']",
      action: "highlight",
      validation: undefined
    },
    {
      id: "search",
      title: "Advanced Search",
      content: "The search functionality helps you find documentation, components, and guides quickly. Try searching for 'performance'.",
      target: ".advanced-search",
      action: "interact",
      validation: "search_performed"
    },
    {
      id: "documentation",
      title: "Documentation Structure",
      content: "Documentation is organized by constitutional principles: Performance, Accessibility, Compliance, and Implementation guides.",
      target: ".documentation-links",
      action: "highlight",
      validation: undefined
    },
    {
      id: "constitutional_compliance",
      title: "Constitutional Compliance",
      content: "Monitor compliance with our five core principles: Zero GitHub Actions, Performance Excellence, User Preservation, Branch Preservation, and Local Validation.",
      target: ".compliance-dashboard",
      action: "highlight",
      validation: undefined
    }
  ],
  components: [
    {
      id: "component_overview",
      title: "Component Library",
      content: "Our component library is built with shadcn/ui and Astro for optimal performance and accessibility.",
      target: ".component-showcase",
      action: "highlight",
      validation: undefined
    },
    {
      id: "theme_toggle",
      title: "Theme System",
      content: "Toggle between light and dark themes. The system remembers your preference and prevents FOUC (Flash of Unstyled Content).",
      target: ".theme-toggle",
      action: "interact",
      validation: "theme_changed"
    },
    {
      id: "accessibility",
      title: "Accessibility Features",
      content: "All components meet WCAG 2.1 AA standards with full keyboard navigation, screen reader support, and proper contrast ratios.",
      target: ".accessibility-validator",
      action: "highlight",
      validation: undefined
    }
  ],
  performance: [
    {
      id: "performance_overview",
      title: "Performance Excellence",
      content: "The framework maintains constitutional performance targets: Lighthouse 95+, <100KB JS, <2.5s LCP.",
      target: ".performance-metrics",
      action: "highlight",
      validation: undefined
    },
    {
      id: "core_web_vitals",
      title: "Core Web Vitals",
      content: "Monitor First Contentful Paint, Largest Contentful Paint, Cumulative Layout Shift, and First Input Delay in real-time.",
      target: ".core-vitals",
      action: "highlight",
      validation: undefined
    },
    {
      id: "optimization_tools",
      title: "Optimization Tools",
      content: "Use the built-in performance monitoring and optimization tools to maintain constitutional compliance.",
      target: ".optimization-tools",
      action: "interact",
      validation: undefined
    }
  ]
};

const tutorialSteps = steps.length > 0 ? steps : defaultSteps[tutorialId as keyof typeof defaultSteps] || [];
const stepCount = tutorialSteps.length;
---

<div class={`interactive-tutorial ${className || ''}`} data-tutorial-id={tutorialId} data-auto-start={autoStart}>
  <!-- Tutorial Trigger Button -->
  <button
    type="button"
    class="tutorial-trigger"
    aria-label={`Start ${title} tutorial`}
    data-tutorial-trigger
  >
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
      <circle cx="12" cy="12" r="10"></circle>
      <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
      <path d="M12 17h.01"></path>
    </svg>
    Help & Tutorial
  </button>

  <!-- Tutorial Modal -->
  <div
    class="tutorial-modal"
    role="dialog"
    aria-labelledby="tutorial-title"
    aria-describedby="tutorial-description"
    aria-modal="true"
    hidden
    data-tutorial-modal
  >
    <div class="tutorial-backdrop" data-tutorial-close></div>

    <div class="tutorial-container">
      <!-- Tutorial Header -->
      <header class="tutorial-header">
        <div class="tutorial-info">
          <h2 id="tutorial-title" class="tutorial-title">{title}</h2>
          <p id="tutorial-description" class="tutorial-description">{description}</p>
        </div>

        <button
          type="button"
          class="tutorial-close"
          aria-label="Close tutorial"
          data-tutorial-close
        >
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </header>

      <!-- Tutorial Progress -->
      <div class="tutorial-progress" aria-label="Tutorial progress">
        <div class="progress-bar">
          <div class="progress-fill" style="width: 0%" data-tutorial-progress></div>
        </div>
        <div class="progress-text">
          <span data-current-step>1</span> of <span data-total-steps>{stepCount}</span>
        </div>
      </div>

      <!-- Tutorial Content -->
      <main class="tutorial-content">
        {tutorialSteps.map((step, index) => (
          <div
            class="tutorial-step"
            data-step-id={step.id}
            data-step-index={index}
            data-step-target={step.target}
            data-step-action={step.action}
            data-step-validation={step.validation}
            hidden={index !== 0}
          >
            <div class="step-content">
              <h3 class="step-title">{step.title}</h3>
              <div class="step-text" set:html={step.content} />

              {step.action === 'interact' && (
                <div class="step-interaction">
                  <p class="interaction-prompt">
                    {step.validation === 'search_performed' && 'Try using the search function above'}
                    {step.validation === 'theme_changed' && 'Click the theme toggle to switch between light and dark modes'}
                    {!step.validation && 'Interact with the highlighted element'}
                  </p>
                </div>
              )}

              {step.validation && (
                <div class="step-validation" data-validation={step.validation}>
                  <div class="validation-pending">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="validation-icon" aria-hidden="true">
                      <circle cx="12" cy="12" r="10"></circle>
                      <path d="M12 6v6l4 2"></path>
                    </svg>
                    Waiting for interaction...
                  </div>
                  <div class="validation-complete" hidden>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="validation-icon" aria-hidden="true">
                      <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                      <polyline points="22,4 12,14.01 9,11.01"></polyline>
                    </svg>
                    Great job!
                  </div>
                </div>
              )}
            </div>
          </div>
        ))}

        <!-- Tutorial Complete -->
        <div class="tutorial-complete" data-tutorial-complete hidden>
          <div class="complete-content">
            <div class="complete-icon">
              <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22,4 12,14.01 9,11.01"></polyline>
              </svg>
            </div>
            <h3 class="complete-title">Tutorial Complete!</h3>
            <p class="complete-text">
              You've successfully completed the {title.toLowerCase()}. You're now ready to use the constitutional framework effectively.
            </p>
            <div class="complete-actions">
              <button type="button" class="complete-button primary" data-tutorial-restart>
                Restart Tutorial
              </button>
              <button type="button" class="complete-button secondary" data-tutorial-close>
                Close
              </button>
            </div>
          </div>
        </div>
      </main>

      <!-- Tutorial Navigation -->
      <footer class="tutorial-footer">
        <div class="tutorial-navigation">
          <button
            type="button"
            class="nav-button secondary"
            data-tutorial-prev
            disabled
          >
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <polyline points="15,18 9,12 15,6"></polyline>
            </svg>
            Previous
          </button>

          <div class="step-dots">
            {tutorialSteps.map((_, index) => (
              <button
                type="button"
                class={`step-dot ${index === 0 ? 'active' : ''}`}
                aria-label={`Go to step ${index + 1}`}
                data-step-dot={index}
              ></button>
            ))}
          </div>

          <button
            type="button"
            class="nav-button primary"
            data-tutorial-next
          >
            Next
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <polyline points="9,18 15,12 9,6"></polyline>
            </svg>
          </button>
        </div>

        <!-- Tutorial Options -->
        <div class="tutorial-options">
          <label class="option-label">
            <input type="checkbox" class="option-checkbox" data-auto-advance />
            <span class="option-text">Auto-advance after interactions</span>
          </label>

          <button type="button" class="option-button" data-tutorial-skip>
            Skip Tutorial
          </button>
        </div>
      </footer>
    </div>

    <!-- Tutorial Spotlight -->
    <div class="tutorial-spotlight" data-tutorial-spotlight hidden>
      <div class="spotlight-overlay"></div>
      <div class="spotlight-target"></div>
    </div>
  </div>

  <!-- Tutorial Hints (Floating) -->
  <div class="tutorial-hint" data-tutorial-hint hidden>
    <div class="hint-content">
      <div class="hint-text"></div>
      <button type="button" class="hint-dismiss" aria-label="Dismiss hint">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>
    <div class="hint-arrow"></div>
  </div>
</div>

<style>
  /* Tutorial Trigger */
  .tutorial-trigger {
    @apply fixed bottom-6 right-6 z-40 flex items-center gap-2 px-4 py-2
           bg-primary text-primary-foreground rounded-full shadow-lg
           hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-ring
           transition-all duration-200;
  }

  /* Tutorial Modal */
  .tutorial-modal {
    @apply fixed inset-0 z-50 flex items-center justify-center p-4;
  }

  .tutorial-backdrop {
    @apply absolute inset-0 bg-black/50 backdrop-blur-sm;
  }

  .tutorial-container {
    @apply relative w-full max-w-2xl bg-background border border-input rounded-lg shadow-xl
           max-h-[90vh] overflow-hidden flex flex-col;
  }

  /* Tutorial Header */
  .tutorial-header {
    @apply flex items-start justify-between p-6 border-b border-input;
  }

  .tutorial-info {
    @apply flex-1 space-y-2;
  }

  .tutorial-title {
    @apply text-2xl font-bold text-foreground;
  }

  .tutorial-description {
    @apply text-muted-foreground;
  }

  .tutorial-close {
    @apply p-2 rounded-md text-muted-foreground hover:text-foreground hover:bg-accent
           focus:outline-none focus:ring-2 focus:ring-ring
           transition-colors duration-200;
  }

  /* Tutorial Progress */
  .tutorial-progress {
    @apply px-6 py-4 border-b border-input space-y-2;
  }

  .progress-bar {
    @apply w-full h-2 bg-muted rounded-full overflow-hidden;
  }

  .progress-fill {
    @apply h-full bg-primary rounded-full transition-all duration-300 ease-out;
  }

  .progress-text {
    @apply text-sm text-muted-foreground text-center;
  }

  /* Tutorial Content */
  .tutorial-content {
    @apply flex-1 overflow-y-auto p-6 space-y-6;
  }

  .tutorial-step {
    @apply space-y-4;
  }

  .step-content {
    @apply space-y-4;
  }

  .step-title {
    @apply text-xl font-semibold text-foreground;
  }

  .step-text {
    @apply text-foreground leading-relaxed;
  }

  .step-interaction {
    @apply p-4 bg-primary/10 border border-primary/20 rounded-lg;
  }

  .interaction-prompt {
    @apply text-primary font-medium;
  }

  /* Step Validation */
  .step-validation {
    @apply flex items-center gap-2 text-sm;
  }

  .validation-pending {
    @apply flex items-center gap-2 text-muted-foreground;
  }

  .validation-complete {
    @apply flex items-center gap-2 text-success;
  }

  .validation-icon {
    @apply animate-spin;
  }

  .validation-complete .validation-icon {
    @apply animate-none;
  }

  /* Tutorial Complete */
  .tutorial-complete {
    @apply text-center space-y-6;
  }

  .complete-content {
    @apply space-y-4;
  }

  .complete-icon {
    @apply flex justify-center text-success;
  }

  .complete-title {
    @apply text-2xl font-bold text-foreground;
  }

  .complete-text {
    @apply text-muted-foreground;
  }

  .complete-actions {
    @apply flex justify-center gap-3;
  }

  .complete-button {
    @apply px-4 py-2 rounded-md font-medium transition-colors duration-200
           focus:outline-none focus:ring-2 focus:ring-ring;
  }

  .complete-button.primary {
    @apply bg-primary text-primary-foreground hover:bg-primary/90;
  }

  .complete-button.secondary {
    @apply bg-secondary text-secondary-foreground hover:bg-secondary/80;
  }

  /* Tutorial Footer */
  .tutorial-footer {
    @apply p-6 border-t border-input space-y-4;
  }

  .tutorial-navigation {
    @apply flex items-center justify-between;
  }

  .nav-button {
    @apply flex items-center gap-2 px-4 py-2 rounded-md font-medium
           transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-ring
           disabled:opacity-50 disabled:cursor-not-allowed;
  }

  .nav-button.primary {
    @apply bg-primary text-primary-foreground hover:bg-primary/90
           disabled:hover:bg-primary;
  }

  .nav-button.secondary {
    @apply bg-secondary text-secondary-foreground hover:bg-secondary/80
           disabled:hover:bg-secondary;
  }

  /* Step Dots */
  .step-dots {
    @apply flex items-center gap-2;
  }

  .step-dot {
    @apply w-3 h-3 rounded-full border-2 border-muted-foreground/30
           hover:border-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring
           transition-colors duration-200;
  }

  .step-dot.active {
    @apply border-primary bg-primary;
  }

  .step-dot.completed {
    @apply border-success bg-success;
  }

  /* Tutorial Options */
  .tutorial-options {
    @apply flex items-center justify-between text-sm;
  }

  .option-label {
    @apply flex items-center gap-2 cursor-pointer;
  }

  .option-checkbox {
    @apply rounded border-input text-primary focus:ring-ring;
  }

  .option-text {
    @apply text-foreground;
  }

  .option-button {
    @apply text-muted-foreground hover:text-foreground transition-colors duration-200;
  }

  /* Tutorial Spotlight */
  .tutorial-spotlight {
    @apply fixed inset-0 z-40 pointer-events-none;
  }

  .spotlight-overlay {
    @apply absolute inset-0 bg-black/70 transition-opacity duration-300;
  }

  .spotlight-target {
    @apply absolute border-2 border-primary rounded-lg shadow-xl
           transition-all duration-300 ease-out;
    box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.1), 0 0 20px rgba(0, 0, 0, 0.3);
  }

  /* Tutorial Hint */
  .tutorial-hint {
    @apply fixed z-50 max-w-xs;
  }

  .hint-content {
    @apply flex items-start gap-3 p-3 bg-popover text-popover-foreground
           border border-border rounded-lg shadow-lg;
  }

  .hint-text {
    @apply flex-1 text-sm;
  }

  .hint-dismiss {
    @apply p-1 rounded-md text-muted-foreground hover:text-foreground
           hover:bg-accent focus:outline-none focus:ring-2 focus:ring-ring;
  }

  .hint-arrow {
    @apply absolute w-3 h-3 bg-popover border-l border-t border-border
           transform rotate-45;
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    .tutorial-container {
      @apply mx-2 max-h-[95vh];
    }

    .tutorial-header {
      @apply p-4;
    }

    .tutorial-content {
      @apply p-4;
    }

    .tutorial-footer {
      @apply p-4;
    }

    .tutorial-navigation {
      @apply flex-col gap-3;
    }

    .step-dots {
      @apply order-first;
    }

    .tutorial-trigger {
      @apply bottom-4 right-4 px-3 py-2;
    }
  }

  /* Accessibility Enhancements */
  @media (prefers-reduced-motion: reduce) {
    .progress-fill,
    .spotlight-target,
    .spotlight-overlay,
    .nav-button,
    .step-dot {
      @apply transition-none;
    }

    .validation-icon {
      @apply animate-none;
    }
  }

  /* High Contrast Mode */
  @media (prefers-contrast: high) {
    .tutorial-container {
      @apply border-2;
    }

    .step-dot {
      @apply border-2;
    }
  }

  /* Dark Mode Optimizations */
  .dark .spotlight-overlay {
    @apply bg-black/80;
  }

  .dark .spotlight-target {
    box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.2), 0 0 20px rgba(0, 0, 0, 0.5);
  }
</style>

<script>
  // Progressive enhancement for interactive tutorial
  class InteractiveTutorial {
    private container: HTMLElement;
    private modal: HTMLElement;
    private currentStep: number = 0;
    private steps: NodeListOf<HTMLElement>;
    private autoAdvance: boolean = false;
    private tutorialId: string;
    private validationCallbacks: Map<string, () => boolean> = new Map();

    constructor(container: HTMLElement) {
      this.container = container;
      this.tutorialId = container.dataset.tutorialId || '';
      this.modal = container.querySelector('[data-tutorial-modal]') as HTMLElement;
      this.steps = container.querySelectorAll('.tutorial-step');

      this.init();
    }

    private init() {
      this.setupEventListeners();
      this.setupValidationCallbacks();
      this.loadProgress();

      // Auto-start if specified
      if (this.container.dataset.autoStart === 'true') {
        this.startTutorial();
      }
    }

    private setupEventListeners() {
      // Tutorial trigger
      const trigger = this.container.querySelector('[data-tutorial-trigger]');
      trigger?.addEventListener('click', () => this.startTutorial());

      // Close buttons
      const closeButtons = this.container.querySelectorAll('[data-tutorial-close]');
      closeButtons.forEach(button => {
        button.addEventListener('click', () => this.closeTutorial());
      });

      // Navigation buttons
      const prevButton = this.container.querySelector('[data-tutorial-prev]');
      const nextButton = this.container.querySelector('[data-tutorial-next]');

      prevButton?.addEventListener('click', () => this.previousStep());
      nextButton?.addEventListener('click', () => this.nextStep());

      // Step dots
      const stepDots = this.container.querySelectorAll('[data-step-dot]');
      stepDots.forEach((dot, index) => {
        dot.addEventListener('click', () => this.goToStep(index));
      });

      // Auto-advance checkbox
      const autoAdvanceCheckbox = this.container.querySelector('[data-auto-advance]') as HTMLInputElement;
      autoAdvanceCheckbox?.addEventListener('change', (e) => {
        this.autoAdvance = (e.target as HTMLInputElement).checked;
      });

      // Skip button
      const skipButton = this.container.querySelector('[data-tutorial-skip]');
      skipButton?.addEventListener('click', () => this.skipTutorial());

      // Restart button
      const restartButton = this.container.querySelector('[data-tutorial-restart]');
      restartButton?.addEventListener('click', () => this.restartTutorial());

      // Keyboard navigation
      document.addEventListener('keydown', (e) => {
        if (!this.modal.hidden) {
          this.handleKeyboardNavigation(e);
        }
      });

      // Click outside to close
      this.modal.addEventListener('click', (e) => {
        if (e.target === this.modal.querySelector('.tutorial-backdrop')) {
          this.closeTutorial();
        }
      });
    }

    private setupValidationCallbacks() {
      // Search validation
      this.validationCallbacks.set('search_performed', () => {
        const searchInput = document.querySelector('.search-input') as HTMLInputElement;
        return searchInput && searchInput.value.length > 0;
      });

      // Theme change validation
      this.validationCallbacks.set('theme_changed', () => {
        const themeToggle = document.querySelector('[data-theme-toggle]');
        return themeToggle !== null; // Simplified - would check actual theme change
      });

      // Set up observers for validations
      this.observeValidations();
    }

    private observeValidations() {
      // Observe search input
      const searchInput = document.querySelector('.search-input');
      if (searchInput) {
        searchInput.addEventListener('input', () => {
          this.checkValidation('search_performed');
        });
      }

      // Observe theme toggle
      const themeToggle = document.querySelector('[data-theme-toggle]');
      if (themeToggle) {
        themeToggle.addEventListener('click', () => {
          setTimeout(() => this.checkValidation('theme_changed'), 100);
        });
      }
    }

    private checkValidation(validationType: string) {
      const currentStepEl = this.steps[this.currentStep];
      const stepValidation = currentStepEl?.dataset.stepValidation;

      if (stepValidation === validationType) {
        const callback = this.validationCallbacks.get(validationType);
        if (callback && callback()) {
          this.markValidationComplete();

          if (this.autoAdvance) {
            setTimeout(() => this.nextStep(), 1500);
          }
        }
      }
    }

    private markValidationComplete() {
      const currentStepEl = this.steps[this.currentStep];
      if (!currentStepEl) return;

      const validationEl = currentStepEl.querySelector('.step-validation');

      if (validationEl) {
        const pending = validationEl.querySelector('.validation-pending');
        const complete = validationEl.querySelector('.validation-complete');

        if (pending) pending.setAttribute('hidden', '');
        if (complete) complete.removeAttribute('hidden');
      }
    }

    private startTutorial() {
      this.modal.removeAttribute('hidden');
      this.currentStep = 0;
      this.showStep(0);
      this.updateProgress();

      // Focus management
      const firstFocusable = this.modal.querySelector('.tutorial-close') as HTMLElement;
      firstFocusable?.focus();

      // Announce to screen readers
      this.announceToScreenReader('Tutorial started');
    }

    private closeTutorial() {
      this.modal.setAttribute('hidden', '');
      this.hideSpotlight();
      this.saveProgress();

      // Return focus to trigger
      const trigger = this.container.querySelector('[data-tutorial-trigger]') as HTMLElement;
      trigger?.focus();

      // Announce to screen readers
      this.announceToScreenReader('Tutorial closed');
    }

    private nextStep() {
      if (this.currentStep < this.steps.length - 1) {
        this.currentStep++;
        this.showStep(this.currentStep);
        this.updateProgress();
      } else {
        this.completeTutorial();
      }
    }

    private previousStep() {
      if (this.currentStep > 0) {
        this.currentStep--;
        this.showStep(this.currentStep);
        this.updateProgress();
      }
    }

    private goToStep(stepIndex: number) {
      if (stepIndex >= 0 && stepIndex < this.steps.length) {
        this.currentStep = stepIndex;
        this.showStep(this.currentStep);
        this.updateProgress();
      }
    }

    private showStep(stepIndex: number) {
      // Hide all steps
      this.steps.forEach(step => step.setAttribute('hidden', ''));

      // Show current step
      const currentStep = this.steps[stepIndex];
      if (currentStep) {
        currentStep.removeAttribute('hidden');

        // Update step dots
        this.updateStepDots();

        // Update navigation buttons
        this.updateNavigationButtons();

        // Handle step actions
        this.handleStepAction(currentStep);

        // Announce step to screen readers
        const stepTitle = currentStep.querySelector('.step-title')?.textContent || '';
        this.announceToScreenReader(`Step ${stepIndex + 1}: ${stepTitle}`);
      }
    }

    private updateStepDots() {
      const dots = this.container.querySelectorAll('[data-step-dot]');
      dots.forEach((dot, index) => {
        dot.classList.remove('active', 'completed');

        if (index === this.currentStep) {
          dot.classList.add('active');
        } else if (index < this.currentStep) {
          dot.classList.add('completed');
        }
      });
    }

    private updateNavigationButtons() {
      const prevButton = this.container.querySelector('[data-tutorial-prev]') as HTMLButtonElement;
      const nextButton = this.container.querySelector('[data-tutorial-next]') as HTMLButtonElement;

      if (prevButton) {
        prevButton.disabled = this.currentStep === 0;
      }

      if (nextButton) {
        if (this.currentStep === this.steps.length - 1) {
          nextButton.textContent = 'Complete';
        } else {
          nextButton.innerHTML = 'Next <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"><polyline points="9,18 15,12 9,6"></polyline></svg>';
        }
      }
    }

    private updateProgress() {
      const progressFill = this.container.querySelector('[data-tutorial-progress]') as HTMLElement;
      const currentStepEl = this.container.querySelector('[data-current-step]');
      const totalStepsEl = this.container.querySelector('[data-total-steps]');

      const progress = ((this.currentStep + 1) / this.steps.length) * 100;

      if (progressFill) {
        progressFill.style.width = `${progress}%`;
      }

      if (currentStepEl) {
        currentStepEl.textContent = (this.currentStep + 1).toString();
      }

      if (totalStepsEl) {
        totalStepsEl.textContent = this.steps.length.toString();
      }
    }

    private handleStepAction(stepEl: HTMLElement) {
      const action = stepEl.dataset.stepAction;
      const target = stepEl.dataset.stepTarget;

      switch (action) {
        case 'highlight':
          if (target) {
            this.highlightElement(target);
          }
          break;
        case 'interact':
          if (target) {
            this.showInteractionHint(target);
          }
          break;
        default:
          this.hideSpotlight();
      }
    }

    private highlightElement(selector: string) {
      const targetElement = document.querySelector(selector);
      if (targetElement) {
        this.showSpotlight(targetElement as HTMLElement);
      }
    }

    private showInteractionHint(selector: string) {
      const targetElement = document.querySelector(selector) as HTMLElement;
      if (targetElement) {
        this.showSpotlight(targetElement);
        this.showHint(targetElement, 'Try interacting with this element');
      }
    }

    private showSpotlight(element: HTMLElement) {
      const spotlight = this.container.querySelector('[data-tutorial-spotlight]') as HTMLElement;
      const spotlightTarget = spotlight.querySelector('.spotlight-target') as HTMLElement;

      if (spotlight && spotlightTarget) {
        const rect = element.getBoundingClientRect();
        const padding = 8;

        spotlightTarget.style.cssText = `
          top: ${rect.top - padding}px;
          left: ${rect.left - padding}px;
          width: ${rect.width + padding * 2}px;
          height: ${rect.height + padding * 2}px;
        `;

        spotlight.removeAttribute('hidden');
      }
    }

    private hideSpotlight() {
      const spotlight = this.container.querySelector('[data-tutorial-spotlight]') as HTMLElement;
      if (spotlight) {
        spotlight.setAttribute('hidden', '');
      }
    }

    private showHint(element: HTMLElement, text: string) {
      const hint = this.container.querySelector('[data-tutorial-hint]') as HTMLElement;
      const hintText = hint.querySelector('.hint-text') as HTMLElement;

      if (hint && hintText) {
        hintText.textContent = text;
        this.positionHint(hint, element);
        hint.removeAttribute('hidden');

        // Auto-hide hint after 5 seconds
        setTimeout(() => {
          hint.setAttribute('hidden', '');
        }, 5000);
      }
    }

    private positionHint(hint: HTMLElement, anchor: HTMLElement) {
      const anchorRect = anchor.getBoundingClientRect();
      const hintRect = hint.getBoundingClientRect();

      let top = anchorRect.bottom + 10;
      let left = anchorRect.left + (anchorRect.width - hintRect.width) / 2;

      // Adjust if hint would go off screen
      if (left < 10) left = 10;
      if (left + hintRect.width > window.innerWidth - 10) {
        left = window.innerWidth - hintRect.width - 10;
      }
      if (top + hintRect.height > window.innerHeight - 10) {
        top = anchorRect.top - hintRect.height - 10;
      }

      hint.style.cssText = `
        top: ${top}px;
        left: ${left}px;
      `;
    }

    private completeTutorial() {
      // Hide current step and show completion
      this.steps.forEach(step => step.setAttribute('hidden', ''));
      const completeEl = this.container.querySelector('[data-tutorial-complete]') as HTMLElement;
      if (completeEl) {
        completeEl.removeAttribute('hidden');
      }

      // Update progress to 100%
      const progressFill = this.container.querySelector('[data-tutorial-progress]') as HTMLElement;
      if (progressFill) {
        progressFill.style.width = '100%';
      }

      // Hide spotlight
      this.hideSpotlight();

      // Mark tutorial as completed
      this.markTutorialCompleted();

      // Announce completion
      this.announceToScreenReader('Tutorial completed successfully');
    }

    private skipTutorial() {
      this.markTutorialCompleted();
      this.closeTutorial();
    }

    private restartTutorial() {
      this.currentStep = 0;
      const completeEl = this.container.querySelector('[data-tutorial-complete]') as HTMLElement;
      if (completeEl) {
        completeEl.setAttribute('hidden', '');
      }
      this.showStep(0);
      this.updateProgress();
    }

    private handleKeyboardNavigation(e: KeyboardEvent) {
      switch (e.key) {
        case 'Escape':
          e.preventDefault();
          this.closeTutorial();
          break;
        case 'ArrowRight':
        case 'ArrowDown':
          e.preventDefault();
          this.nextStep();
          break;
        case 'ArrowLeft':
        case 'ArrowUp':
          e.preventDefault();
          this.previousStep();
          break;
        case 'Home':
          e.preventDefault();
          this.goToStep(0);
          break;
        case 'End':
          e.preventDefault();
          this.goToStep(this.steps.length - 1);
          break;
      }
    }

    private announceToScreenReader(message: string) {
      const announcer = document.createElement('div');
      announcer.setAttribute('aria-live', 'polite');
      announcer.setAttribute('aria-atomic', 'true');
      announcer.className = 'sr-only';
      announcer.textContent = message;

      document.body.appendChild(announcer);
      setTimeout(() => document.body.removeChild(announcer), 1000);
    }

    private saveProgress() {
      const progress = {
        tutorialId: this.tutorialId,
        currentStep: this.currentStep,
        completed: this.isCompleted(),
        lastAccess: Date.now()
      };

      localStorage.setItem(`tutorial_${this.tutorialId}`, JSON.stringify(progress));
    }

    private loadProgress() {
      const saved = localStorage.getItem(`tutorial_${this.tutorialId}`);
      if (saved) {
        try {
          const progress = JSON.parse(saved);
          if (progress.completed) {
            this.markTutorialCompleted();
          }
        } catch (e) {
          console.warn('Failed to load tutorial progress:', e);
        }
      }
    }

    private markTutorialCompleted() {
      const trigger = this.container.querySelector('[data-tutorial-trigger]') as HTMLElement;
      if (trigger) {
        trigger.classList.add('completed');
        trigger.setAttribute('aria-label', 'Tutorial completed - Click to restart');
      }

      this.saveProgress();
    }

    private isCompleted(): boolean {
      return this.currentStep >= this.steps.length - 1;
    }
  }

  // Initialize all tutorials
  const initializeTutorials = () => {
    const tutorials = document.querySelectorAll('.interactive-tutorial');
    tutorials.forEach(tutorial => {
      new InteractiveTutorial(tutorial as HTMLElement);
    });
  };

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeTutorials);
  } else {
    initializeTutorials();
  }

  // Add CSS class for completed tutorials
  const completedTutorialStyles = `
    .tutorial-trigger.completed {
      background-color: hsl(var(--success));
      color: hsl(var(--success-foreground));
    }
    .tutorial-trigger.completed:hover {
      background-color: hsl(var(--success) / 0.9);
    }
  `;

  const styleSheet = document.createElement('style');
  styleSheet.textContent = completedTutorialStyles;
  document.head.appendChild(styleSheet);
</script>

<style>
  /* Screen Reader Only */
  .sr-only {
    @apply absolute w-px h-px p-0 -m-px overflow-hidden whitespace-nowrap border-0;
    clip: rect(0, 0, 0, 0);
  }

  /* Tutorial trigger completed state will be added via JavaScript */
</style>